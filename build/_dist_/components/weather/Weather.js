import './Weather.css.proxy.js';
/* src\components\weather\Weather.svelte generated by Svelte v3.31.2 */
import {
	SvelteComponent,
	action_destroyer,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	handle_promise,
	init,
	insert,
	is_function,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import {
	locationStore,
	weatherStore,
	databaseStore,
	networkStatus
} from "../../stores/stores.js";

// actions
import createChart from "../../actions/createChart.js";

// components
import LoadingWeather from "../loading/LoadingWeather.js";

import SectionHeading from "../heading/SectionHeading.js";
import NavBar from "../navigation/NavBar.js";
import Basic from "./Basic.js";
import Details from "./Details.js";
import Next48Hours from "./Next48Hours.js";
import Next7Days from "./Next7Days.js";

function create_catch_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (47:0) {:then}
function create_then_block(ctx) {
	let basic;
	let updating_bookmarkIndex;
	let t0;
	let navbar;
	let updating_componentName;
	let t1;
	let sectionheading0;
	let t2;
	let details;
	let t3;
	let sectionheading1;
	let t4;
	let div;
	let canvas;
	let createChart_action;
	let t5;
	let sectionheading2;
	let t6;
	let next48hours;
	let updating_hourlyIndex;
	let t7;
	let sectionheading3;
	let t8;
	let next7days;
	let current;
	let mounted;
	let dispose;

	function basic_bookmarkIndex_binding(value) {
		/*basic_bookmarkIndex_binding*/ ctx[15].call(null, value);
	}

	let basic_props = {
		current: /*current*/ ctx[5],
		hourly: /*hourly*/ ctx[6],
		hourlyIndex: /*hourlyIndex*/ ctx[2],
		bookmarks: /*bookmarks*/ ctx[4],
		units: /*units*/ ctx[1]
	};

	if (/*bookmarkIndex*/ ctx[3] !== void 0) {
		basic_props.bookmarkIndex = /*bookmarkIndex*/ ctx[3];
	}

	basic = new Basic({ props: basic_props });
	binding_callbacks.push(() => bind(basic, "bookmarkIndex", basic_bookmarkIndex_binding));

	function navbar_componentName_binding(value) {
		/*navbar_componentName_binding*/ ctx[16].call(null, value);
	}

	let navbar_props = {};

	if (/*componentName*/ ctx[0] !== void 0) {
		navbar_props.componentName = /*componentName*/ ctx[0];
	}

	navbar = new NavBar({ props: navbar_props });
	binding_callbacks.push(() => bind(navbar, "componentName", navbar_componentName_binding));
	sectionheading0 = new SectionHeading({ props: { title: "Details" } });

	details = new Details({
			props: {
				hourly: /*hourly*/ ctx[6],
				hourlyIndex: /*hourlyIndex*/ ctx[2],
				units: /*units*/ ctx[1]
			}
		});

	sectionheading1 = new SectionHeading({ props: { title: "Precipitation" } });
	sectionheading2 = new SectionHeading({ props: { title: "Next 48 Hours" } });

	function next48hours_hourlyIndex_binding(value) {
		/*next48hours_hourlyIndex_binding*/ ctx[17].call(null, value);
	}

	let next48hours_props = {
		hourly: /*hourly*/ ctx[6],
		units: /*units*/ ctx[1]
	};

	if (/*hourlyIndex*/ ctx[2] !== void 0) {
		next48hours_props.hourlyIndex = /*hourlyIndex*/ ctx[2];
	}

	next48hours = new Next48Hours({ props: next48hours_props });
	binding_callbacks.push(() => bind(next48hours, "hourlyIndex", next48hours_hourlyIndex_binding));
	sectionheading3 = new SectionHeading({ props: { title: "Next 7 Days" } });
	next7days = new Next7Days({ props: { daily: /*daily*/ ctx[7] } });

	return {
		c() {
			create_component(basic.$$.fragment);
			t0 = space();
			create_component(navbar.$$.fragment);
			t1 = space();
			create_component(sectionheading0.$$.fragment);
			t2 = space();
			create_component(details.$$.fragment);
			t3 = space();
			create_component(sectionheading1.$$.fragment);
			t4 = space();
			div = element("div");
			canvas = element("canvas");
			t5 = space();
			create_component(sectionheading2.$$.fragment);
			t6 = space();
			create_component(next48hours.$$.fragment);
			t7 = space();
			create_component(sectionheading3.$$.fragment);
			t8 = space();
			create_component(next7days.$$.fragment);
			attr(canvas, "class", "chart svelte-1cgwkid");
			attr(div, "class", "wrapper-chart svelte-1cgwkid");
		},
		m(target, anchor) {
			mount_component(basic, target, anchor);
			insert(target, t0, anchor);
			mount_component(navbar, target, anchor);
			insert(target, t1, anchor);
			mount_component(sectionheading0, target, anchor);
			insert(target, t2, anchor);
			mount_component(details, target, anchor);
			insert(target, t3, anchor);
			mount_component(sectionheading1, target, anchor);
			insert(target, t4, anchor);
			insert(target, div, anchor);
			append(div, canvas);
			insert(target, t5, anchor);
			mount_component(sectionheading2, target, anchor);
			insert(target, t6, anchor);
			mount_component(next48hours, target, anchor);
			insert(target, t7, anchor);
			mount_component(sectionheading3, target, anchor);
			insert(target, t8, anchor);
			mount_component(next7days, target, anchor);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(createChart_action = createChart.call(null, canvas, {
					hourly: /*hourly*/ ctx[6],
					index: /*hourlyIndex*/ ctx[2]
				}));

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const basic_changes = {};
			if (dirty & /*current*/ 32) basic_changes.current = /*current*/ ctx[5];
			if (dirty & /*hourly*/ 64) basic_changes.hourly = /*hourly*/ ctx[6];
			if (dirty & /*hourlyIndex*/ 4) basic_changes.hourlyIndex = /*hourlyIndex*/ ctx[2];
			if (dirty & /*bookmarks*/ 16) basic_changes.bookmarks = /*bookmarks*/ ctx[4];
			if (dirty & /*units*/ 2) basic_changes.units = /*units*/ ctx[1];

			if (!updating_bookmarkIndex && dirty & /*bookmarkIndex*/ 8) {
				updating_bookmarkIndex = true;
				basic_changes.bookmarkIndex = /*bookmarkIndex*/ ctx[3];
				add_flush_callback(() => updating_bookmarkIndex = false);
			}

			basic.$set(basic_changes);
			const navbar_changes = {};

			if (!updating_componentName && dirty & /*componentName*/ 1) {
				updating_componentName = true;
				navbar_changes.componentName = /*componentName*/ ctx[0];
				add_flush_callback(() => updating_componentName = false);
			}

			navbar.$set(navbar_changes);
			const details_changes = {};
			if (dirty & /*hourly*/ 64) details_changes.hourly = /*hourly*/ ctx[6];
			if (dirty & /*hourlyIndex*/ 4) details_changes.hourlyIndex = /*hourlyIndex*/ ctx[2];
			if (dirty & /*units*/ 2) details_changes.units = /*units*/ ctx[1];
			details.$set(details_changes);

			if (createChart_action && is_function(createChart_action.update) && dirty & /*hourly, hourlyIndex*/ 68) createChart_action.update.call(null, {
				hourly: /*hourly*/ ctx[6],
				index: /*hourlyIndex*/ ctx[2]
			});

			const next48hours_changes = {};
			if (dirty & /*hourly*/ 64) next48hours_changes.hourly = /*hourly*/ ctx[6];
			if (dirty & /*units*/ 2) next48hours_changes.units = /*units*/ ctx[1];

			if (!updating_hourlyIndex && dirty & /*hourlyIndex*/ 4) {
				updating_hourlyIndex = true;
				next48hours_changes.hourlyIndex = /*hourlyIndex*/ ctx[2];
				add_flush_callback(() => updating_hourlyIndex = false);
			}

			next48hours.$set(next48hours_changes);
			const next7days_changes = {};
			if (dirty & /*daily*/ 128) next7days_changes.daily = /*daily*/ ctx[7];
			next7days.$set(next7days_changes);
		},
		i(local) {
			if (current) return;
			transition_in(basic.$$.fragment, local);
			transition_in(navbar.$$.fragment, local);
			transition_in(sectionheading0.$$.fragment, local);
			transition_in(details.$$.fragment, local);
			transition_in(sectionheading1.$$.fragment, local);
			transition_in(sectionheading2.$$.fragment, local);
			transition_in(next48hours.$$.fragment, local);
			transition_in(sectionheading3.$$.fragment, local);
			transition_in(next7days.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(basic.$$.fragment, local);
			transition_out(navbar.$$.fragment, local);
			transition_out(sectionheading0.$$.fragment, local);
			transition_out(details.$$.fragment, local);
			transition_out(sectionheading1.$$.fragment, local);
			transition_out(sectionheading2.$$.fragment, local);
			transition_out(next48hours.$$.fragment, local);
			transition_out(sectionheading3.$$.fragment, local);
			transition_out(next7days.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(basic, detaching);
			if (detaching) detach(t0);
			destroy_component(navbar, detaching);
			if (detaching) detach(t1);
			destroy_component(sectionheading0, detaching);
			if (detaching) detach(t2);
			destroy_component(details, detaching);
			if (detaching) detach(t3);
			destroy_component(sectionheading1, detaching);
			if (detaching) detach(t4);
			if (detaching) detach(div);
			if (detaching) detach(t5);
			destroy_component(sectionheading2, detaching);
			if (detaching) detach(t6);
			destroy_component(next48hours, detaching);
			if (detaching) detach(t7);
			destroy_component(sectionheading3, detaching);
			if (detaching) detach(t8);
			destroy_component(next7days, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (43:18)       <LoadingWeather />    {:then}
function create_pending_block(ctx) {
	let loadingweather;
	let current;
	loadingweather = new LoadingWeather({});

	return {
		c() {
			create_component(loadingweather.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loadingweather, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(loadingweather.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loadingweather.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loadingweather, detaching);
		}
	};
}

function create_fragment(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		blocks: [,,,]
	};

	handle_promise(promise = /*isLoading*/ ctx[8], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*isLoading*/ 256 && promise !== (promise = /*isLoading*/ ctx[8]) && handle_promise(promise, info)) {
				
			} else {
				const child_ctx = ctx.slice();
				info.block.p(child_ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let units;
	let bookmarks;
	let isOnline;
	let coords;
	let current;
	let hourly;
	let daily;
	let isLoading;
	let $databaseStore;
	let $networkStatus;
	let $locationStore;
	let $weatherStore;
	component_subscribe($$self, databaseStore, $$value => $$invalidate(9, $databaseStore = $$value));
	component_subscribe($$self, networkStatus, $$value => $$invalidate(11, $networkStatus = $$value));
	component_subscribe($$self, locationStore, $$value => $$invalidate(13, $locationStore = $$value));
	component_subscribe($$self, weatherStore, $$value => $$invalidate(14, $weatherStore = $$value));
	let { componentName } = $$props;

	// active HourlyWthrCard
	let hourlyIndex = 0;

	// active bookmark
	let bookmarkIndex = 0;

	function basic_bookmarkIndex_binding(value) {
		bookmarkIndex = value;
		$$invalidate(3, bookmarkIndex);
	}

	function navbar_componentName_binding(value) {
		componentName = value;
		$$invalidate(0, componentName);
	}

	function next48hours_hourlyIndex_binding(value) {
		hourlyIndex = value;
		$$invalidate(2, hourlyIndex);
	}

	$$self.$$set = $$props => {
		if ("componentName" in $$props) $$invalidate(0, componentName = $$props.componentName);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$databaseStore*/ 512) {
			// Navigator API geolocation flag, units ('metric'/'imperial'), bookmarked cities
			$: $$invalidate(1, { settings: { units }, bookmarks } = $databaseStore, units, ($$invalidate(4, bookmarks), $$invalidate(9, $databaseStore)));
		}

		if ($$self.$$.dirty & /*$networkStatus*/ 2048) {
			$: $$invalidate(10, { isOnline } = $networkStatus, isOnline);
		}

		if ($$self.$$.dirty & /*$locationStore*/ 8192) {
			// coords
			$: $$invalidate(12, { coords } = $locationStore, coords);
		}

		if ($$self.$$.dirty & /*$weatherStore*/ 16384) {
			// current, hourly & daily weather data
			$: $$invalidate(5, { current, hourly, daily } = $weatherStore, current, ($$invalidate(6, hourly), $$invalidate(14, $weatherStore)), ($$invalidate(7, daily), $$invalidate(14, $weatherStore)));
		}

		if ($$self.$$.dirty & /*isOnline, coords, units*/ 5122) {
			// display LoadingWeather component, fetch weather data and display, on location change ($locationStore)
			$: $$invalidate(8, isLoading = isOnline && weatherStore.fetchWeatherData(coords, units));
		}
	};

	return [
		componentName,
		units,
		hourlyIndex,
		bookmarkIndex,
		bookmarks,
		current,
		hourly,
		daily,
		isLoading,
		$databaseStore,
		isOnline,
		$networkStatus,
		coords,
		$locationStore,
		$weatherStore,
		basic_bookmarkIndex_binding,
		navbar_componentName_binding,
		next48hours_hourlyIndex_binding
	];
}

class Weather extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { componentName: 0 });
	}
}

export default Weather;